<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zhangxk&#39;s blog</title>
  
  <subtitle>前端博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhangxuekang.com/"/>
  <updated>2019-04-13T01:57:50.350Z</updated>
  <id>https://zhangxuekang.com/</id>
  
  <author>
    <name>zhangxk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>个人项目集合</title>
    <link href="https://zhangxuekang.com/2100/01/02/projects/"/>
    <id>https://zhangxuekang.com/2100/01/02/projects/</id>
    <published>2100-01-01T16:00:00.000Z</published>
    <updated>2019-04-13T01:57:50.350Z</updated>
    
    <content type="html"><![CDATA[<h1 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h1><ul><li><a href="https://zhangxuekang.com/snake/index.html">贪吃蛇</a></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul><li><a href="https://zhangxuekang.com/rich-text/index.html">draft.js富文本编辑器</a></li><li><a href="https://zhangxuekang.com/web-calendar/index.html">localStorage日历</a></li><li><a href="https://zhangxuekang.com/mouse-show/index.html">跟随鼠标移动的文字特效</a></li><li><a href="https://zhangxuekang.com/mouse-svg/index.html">鼠标轨迹转svg</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;游戏&quot;&gt;&lt;a href=&quot;#游戏&quot; class=&quot;headerlink&quot; title=&quot;游戏&quot;&gt;&lt;/a&gt;游戏&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zhangxuekang.com/snake/index.html&quot;&gt;贪吃蛇&lt;/a&gt;&lt;/li&gt;
      
    
    </summary>
    
      <category term="项目" scheme="https://zhangxuekang.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>每天一个命令行</title>
    <link href="https://zhangxuekang.com/2100/01/01/command-days/"/>
    <id>https://zhangxuekang.com/2100/01/01/command-days/</id>
    <published>2099-12-31T16:00:00.000Z</published>
    <updated>2019-06-17T09:58:15.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="2019-04-08"><a href="#2019-04-08" class="headerlink" title="2019-04-08"></a>2019-04-08</h3><pre><code class="shell">npm list [-g] --depth 0</code></pre><p>查看[全局]安装的npm包，depth 0表示查看最外层的包，depth 1展开一层看看这些模块各自又依赖了哪些模块，以此类推。</p><h3 id="2019-04-09"><a href="#2019-04-09" class="headerlink" title="2019-04-09"></a>2019-04-09</h3><pre><code class="shell">git branch -d &lt;branch-name&gt;</code></pre><p>删除本地分支  </p><pre><code class="shell">git branch -b &lt;branch-name&gt;</code></pre><p>新建本地分支  </p><h3 id="2019-04-10"><a href="#2019-04-10" class="headerlink" title="2019-04-10"></a>2019-04-10</h3><pre><code class="shell">echo "xxx" &gt; file-name.txt</code></pre><p>将内容”xxx”写入file-name.txt文件中，覆盖写入。  </p><pre><code class="shell">echo "xxx" &gt;&gt; file-name.txt</code></pre><p>将内容”xxx”写入file-name.txt文件中，追加写入，echo自动加换行。  </p><h3 id="2019-04-11"><a href="#2019-04-11" class="headerlink" title="2019-04-11"></a>2019-04-11</h3><pre><code class="shell">git checkout &lt;origin-branch-name&gt;</code></pre><p>基于远端分支在本地新建同名分支。  </p><h3 id="2019-04-12"><a href="#2019-04-12" class="headerlink" title="2019-04-12"></a>2019-04-12</h3><pre><code class="shell">git rm -r --cached .</code></pre><p>将所有文件从版本库里移除，-r表示递归，深入文件内部。<br>之后再运行<code>git add .</code>和<code>git commit</code>后，新的.gitignore规则就会生效。  </p><h3 id="2019-04-13"><a href="#2019-04-13" class="headerlink" title="2019-04-13"></a>2019-04-13</h3><pre><code class="shell">history</code></pre><p>显示终端中运行过的命令。  </p><h3 id="2019-04-15"><a href="#2019-04-15" class="headerlink" title="2019-04-15"></a>2019-04-15</h3><pre><code class="shell">touch file-name</code></pre><p>touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间，若文件不存在，系统会建立一个新的文件。<br>也就是说该命令将文件的最后更改时间设置为系统当前时间。  </p><h3 id="2019-04-21"><a href="#2019-04-21" class="headerlink" title="2019-04-21"></a>2019-04-21</h3><pre><code class="shell">kill -9 PID</code></pre><p>结束指定PID的进程，mac可以打开活动监视器查看进程PID。  </p><h3 id="2019-04-23"><a href="#2019-04-23" class="headerlink" title="2019-04-23"></a>2019-04-23</h3><pre><code class="shell">git merge --squash another</code></pre><p>将another分支上的多个commit合并成一个，放在当前分支上，原来的commit历史则没有拿过来，需要填写一个commite记录。  </p><h3 id="2019-05-15"><a href="#2019-05-15" class="headerlink" title="2019-05-15"></a>2019-05-15</h3><pre><code class="shell">ls -l</code></pre><p>列出文件夹内的文件信息。 </p><h3 id="2019-05-19"><a href="#2019-05-19" class="headerlink" title="2019-05-19"></a>2019-05-19</h3><pre><code class="shell">pwd</code></pre><p>显示当前目录路径。 </p><h3 id="2019-05-23"><a href="#2019-05-23" class="headerlink" title="2019-05-23"></a>2019-05-23</h3><pre><code class="shell">git tag &lt;tagname&gt; [commit id]</code></pre><p>创建一个标签，默认为HEAD，可以指定一个commit id。   </p><pre><code class="shell">git tag -a &lt;tagname&gt; -m "blablabla..."</code></pre><p>创建一个带有信息的标签。  </p><h3 id="2019-05-27"><a href="#2019-05-27" class="headerlink" title="2019-05-27"></a>2019-05-27</h3><pre><code class="shell">git tag -d &lt;tagname&gt;</code></pre><p>在本地删除一个标签。</p><pre><code class="shell">git push origin :refs/tags/&lt;tagname&gt;</code></pre><p>这样可以删除远程的标签（需要先在本地删除再删远程）。</p><h3 id="2019-05-28"><a href="#2019-05-28" class="headerlink" title="2019-05-28"></a>2019-05-28</h3><pre><code class="shell">lsof -i tcp:&lt;端口号&gt;</code></pre><p>查询端口号的占用情况，会显示出PID，方便kill。  </p><h3 id="2019-06-17"><a href="#2019-06-17" class="headerlink" title="2019-06-17"></a>2019-06-17</h3><pre><code class="shell">git push origin &lt;xx&gt; -f</code></pre><p>reset –hard版本回退后，只是本地回退。push的时候加-f参数，将远端代码也进行回退。不加参数push不了。 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;2019-04-08&quot;&gt;&lt;a href=&quot;#2019-04-08&quot; class=&quot;headerlink&quot; title=&quot;2019-04-08&quot;&gt;&lt;/a&gt;2019-04-08&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;shell&quot;&gt;npm list [-g] --
      
    
    </summary>
    
      <category term="common" scheme="https://zhangxuekang.com/categories/common/"/>
    
    
      <category term="命令" scheme="https://zhangxuekang.com/tags/%E5%91%BD%E4%BB%A4/"/>
    
      <category term="终端" scheme="https://zhangxuekang.com/tags/%E7%BB%88%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>Unicode笔记</title>
    <link href="https://zhangxuekang.com/2019/05/23/unicode/"/>
    <id>https://zhangxuekang.com/2019/05/23/unicode/</id>
    <published>2019-05-23T12:54:08.000Z</published>
    <updated>2019-05-27T03:27:53.446Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Unicode是什么？"><a href="#1-Unicode是什么？" class="headerlink" title="1. Unicode是什么？"></a>1. Unicode是什么？</h2><p>有一个想法，将全世界所有的字符号都包含在一个集合里边，任何机器支持这一个集合就行了，再也不会有乱码了。基于这个想法，Unicode码应运而生。它用数字编号来表示符号，到7.0版，已经有了109449个符号。一般用26进制表示，’U+4E49’表示字符’义’，’U+’是前缀，整体叫做<em>码点</em>。<br>集合分为几个区间，U+0000~U+FFFF是最常用的字符，称为<em>基本平面</em>，剩下的U+010000~U+10FFFF称为<em>辅助平面</em>。  </p><h2 id="2-编码方式"><a href="#2-编码方式" class="headerlink" title="2. 编码方式"></a>2. 编码方式</h2><p>平常说的UTF-8，UTF-16就是说的码点的编码方式。UTF-32指无论是什么码点，一律使用4个字节表示，一共是8位16进制数，位数不足的，在前边补0，例如U+389D = 0x0000 389D。UTF-8字节数灵活，用1个字节能表示的用1个字节，用两个字节才能表示的，用两个字节，还可能是3个4个字节。同样的文本UTF-8占的存储空间比UTF32小多了。所以，网页编码大部分使用的是UTF-8。  </p><h2 id="3-UTF-16"><a href="#3-UTF-16" class="headerlink" title="3. UTF-16"></a>3. UTF-16</h2><p>重点说一下UTF-16。UTF-16介于以上两者之间，规则也很简单，基本平面的字符占用2个字节，辅助平面的字节占用4个字节。因为常用的字符都在基本平面，所以UTF-16比UTF-32所占空间要小。当我们看到4个字节，如果前两个字节码点的范围是U+D800到U+DBFF，那么后两个字节码点一般在U+DC00到U+DFFF范围内，那么它就是一个4字节字符。但是U+D800到U+DBFF范围内的2个字节的字符怎么办？在基本平面里边U+D800~U+DBFF是一个空段，不对应任何字符（不知道是不是有意为之），所以用这段来表示4字节字符的前段，也叫高位，后边的U+DC00到U+DFFF叫低位。</p><blockquote><p>所以，当我们遇到两个字节，发现它的码点在U+D800到U+DBFF之间，就可以断定，紧跟在后面的两个字节的码点，应该在U+DC00到U+DFFF之间，这四个字节必须放在一起解读。  </p></blockquote><p>给一个辅助平面的码点，怎么转化成UTF-164字节形式呢？有一个公式可用：</p><pre><code class="js">H = <span class="built_in">Math</span>.floor((c - <span class="number">0x10000</span>) / <span class="number">0x400</span>) + <span class="number">0xD800</span>L = (c - <span class="number">0x10000</span>) % <span class="number">0x400</span> + <span class="number">0xDC00</span></code></pre><h2 id="4-javascript中的Unicode"><a href="#4-javascript中的Unicode" class="headerlink" title="4. javascript中的Unicode"></a>4. javascript中的Unicode</h2><p>javascript采用Unicode字符集，支持的编码方式是UCS-2。UTF-16是UCS-2的超集，至于UCS-2是什么，请自行百度。在javascript中处理字符串时，可以看做是UTF-16编码。遇到4个字节的字符，String.prototype.length会得到2，不过在es6中增加了新的api处理4个字节字符的方法，这里就不展开介绍了。js中的表示方法是’\u’+四位16进制数，例如’\u4f60’表示中文’你’，这是一个长度是1的字符。’\u004F\u030C’表示符号’Ǒ’，lendth长度是2。匹配辅助平面的字符的正则：/[\uD800-\uDBFF][\uDC00-\uDFFF]/，匹配到的字符length都是2。首先要将码点转化为高位和低位形式，再与正则比较判断。  </p><h2 id="5-javascript中处理emoji"><a href="#5-javascript中处理emoji" class="headerlink" title="5. javascript中处理emoji"></a>5. javascript中处理emoji</h2><p>emoji实质上也是Unicode码，也可以在javascript中处理。大部分emoji是4个字节，由高位+低位两端编码组成，只要解析的时候不把高位和低位分开，就不会出现’乱码’的情况。但是有些emoji是由多个emoji连接而成，例如：  </p><pre><code class="js">U+<span class="number">1</span>F468：男人U+<span class="number">1</span>F469：女人U+<span class="number">1</span>F467：女孩</code></pre><p>使用连接符号U+200D连接，U+1F468 U+200D U+1F469 U+200D U+1F467，就会显示一个新的emoji表情：家庭，但是如果系统不支持这种表示，还是会显示3个单独的表情。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Unicode是什么？&quot;&gt;&lt;a href=&quot;#1-Unicode是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. Unicode是什么？&quot;&gt;&lt;/a&gt;1. Unicode是什么？&lt;/h2&gt;&lt;p&gt;有一个想法，将全世界所有的字符号都包含在一个集合
      
    
    </summary>
    
      <category term="common" scheme="https://zhangxuekang.com/categories/common/"/>
    
    
  </entry>
  
  <entry>
    <title>踩坑之路</title>
    <link href="https://zhangxuekang.com/2019/05/22/trap/"/>
    <id>https://zhangxuekang.com/2019/05/22/trap/</id>
    <published>2019-05-22T02:20:21.000Z</published>
    <updated>2019-05-28T07:32:58.477Z</updated>
    
    <content type="html"><![CDATA[<ol><li><h3 id="border-dashed在部分机型-ios-Android-上不显示"><a href="#border-dashed在部分机型-ios-Android-上不显示" class="headerlink" title="border dashed在部分机型(ios/Android)上不显示"></a>border dashed在部分机型(ios/Android)上不显示</h3><p>解决方法: 添加属性border-radius, 值设置为0.5或者1都行, 实际中设置了0.1, 样式影响很小. 附上大佬们在github上的讨论:<br><a href="https://github.com/facebook/react-native/issues/12817" target="_blank" rel="noopener"><em>borderStyle ‘dashed’ didn’t work when borderBottomWidth set</em></a>  </p></li><li><h3 id="元素设置transform-scale后的定位问题"><a href="#元素设置transform-scale后的定位问题" class="headerlink" title="元素设置transform scale后的定位问题"></a>元素设置transform scale后的定位问题</h3><p>scale缩放相当于使用放大镜看局部的元素, 眼睛看到元素变大或者缩小了, 但是他实际的大小和占位是不变的, 不会影响周围元素的排布. 如果元素是绝对定位的, left和top是根据元素本来的大小尺寸定位来计算的, 和放大后眼睛看到的’虚像’无关, 但是鼠标点点击区域和眼睛看到的区域值一致的.  </p></li><li><h3 id="window-location-search为空"><a href="#window-location-search为空" class="headerlink" title="window.location.search为空"></a>window.location.search为空</h3><p>亲测3条法则：<br>1、第一个#号后边的任何字符（包括？#等特殊字符），直到href结束，都是hash部分。<br>2、第一个？号后边的非#字符，直到出现#号或者href结束，都是search部分。<br>3、第1条规则优先级大于第2条规则。<br>所以检查是否在？号前边出现了#号，如果出现了，那么search部分是空的，？号部分出现在了hash里边。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;border-dashed在部分机型-ios-Android-上不显示&quot;&gt;&lt;a href=&quot;#border-dashed在部分机型-ios-Android-上不显示&quot; class=&quot;headerlink&quot; title=&quot;border dashed
      
    
    </summary>
    
      <category term="common" scheme="https://zhangxuekang.com/categories/common/"/>
    
    
  </entry>
  
  <entry>
    <title>使用draft.js构建富文本编辑器</title>
    <link href="https://zhangxuekang.com/2019/03/30/draft-rich-text/"/>
    <id>https://zhangxuekang.com/2019/03/30/draft-rich-text/</id>
    <published>2019-03-30T07:46:25.000Z</published>
    <updated>2019-04-07T00:36:53.023Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://draftjs.org/" target="_blank" rel="noopener">Draft.js</a>是一个构建富文本编辑器的React框架, 它不是一个富文本编辑器的组件库. draft.js提供构建编辑器的工具, 如何实现, 需要开发者自己去设计. 砖头和水泥都有了, 就差个程序员去盖房子了.  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>大部分编辑器保存的富文本数据都是html, 数据不够结构化, 查询修改数据很不容易. 而Draft.js提供结构化的数据, 表现能力更加强大.  </li><li>实现富文本功能的过程中你会发现, Draft.js没有直接操作dom. 数据和渲染的完全分离, 使开发者只需要关注数据层.  </li><li>在Draft.js中, 所有的事情都是开发者自己去定制的, 灵活性高, 可扩展性强.  </li><li>不管是多样的行内样式还是复杂块级样式, 使用Draft.js都可以方便配置.  </li></ul><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Draft.js依赖React和React DOM, 确保项目中安装了这两项.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save draft-js react react-dom</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">yarn add draft-js react react-dom</span><br></pre></td></tr></table></figure></p><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;Editor, EditorState&#125; <span class="keyword">from</span> <span class="string">'draft-js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">editorState</span>: EditorState.createEmpty()&#125;;</span><br><span class="line">    <span class="keyword">this</span>.onChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;editorState&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;Editor editorState=&#123;<span class="keyword">this</span>.state.editorState&#125; onChange=&#123;<span class="keyword">this</span>.onChange&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;MyEditor /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果配置正常的话, 应该能看到一个可输入区域.<br>简单看下是怎么实现的, 使用过React表单控件的开发应该知道: </p><blockquote><p>其值由 React 控制的输入表单元素称为“受控组件”。  </p></blockquote><p>Draft.js构建的富文本编辑器也是一个”受控组件”, 使用方法和input控件一样, 指定数据源(this.state.editorState), 添加控制函数(this.onChange). onChange方法触发后, Draft.js会将最新的editorState作为参数传出来, 用新数据渲染, 实现同步更新.<br>因为还没有配置富文本渲染方法, 所以目前还是纯文本编辑器. <a href="https://github.com/facebook/draft-js/issues/1744" target="_blank" rel="noopener">Draft.css</a>文件是默认的渲染样式, 需要在项目中引入生效.  </p><h2 id="行内样式"><a href="#行内样式" class="headerlink" title="行内样式"></a>行内样式</h2><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>RichUtils模块拥有很多操作富文本的方法, 现在我们使用RichUtils.handleKeyCommand来实现快捷键修改文本样式的功能.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">editorState</span>: EditorState.createEmpty()&#125;;</span><br><span class="line">    <span class="keyword">this</span>.onChange = <span class="function">(<span class="params">editorState</span>) =&gt;</span> <span class="keyword">this</span>.setState(&#123;editorState&#125;);</span><br><span class="line">    <span class="keyword">this</span>.handleKeyCommand = <span class="keyword">this</span>.handleKeyCommand.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleKeyCommand(command, editorState) &#123;</span><br><span class="line">    <span class="keyword">const</span> newState = RichUtils.handleKeyCommand(editorState, command);</span><br><span class="line">    <span class="keyword">if</span> (newState) &#123;</span><br><span class="line">      <span class="keyword">this</span>.onChange(newState);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">'handled'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'not-handled'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Editor</span><br><span class="line">        editorState=&#123;<span class="keyword">this</span>.state.editorState&#125;</span><br><span class="line">        handleKeyCommand=&#123;<span class="keyword">this</span>.handleKeyCommand&#125;</span><br><span class="line">        onChange=&#123;<span class="keyword">this</span>.onChange&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>handleKeyCommand是控制键盘快捷键的接口.<br>Draft.js默认的快捷键有Cmd+B(加粗), Cmd+I(斜体)等, 当然, 你也可以自己定义快捷键.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Editor, getDefaultKeyBinding, KeyBindingUtil&#125; <span class="keyword">from</span> <span class="string">'draft-js'</span>;</span><br><span class="line"><span class="keyword">const</span> &#123;hasCommandModifier&#125; = KeyBindingUtil;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  handleKeyCommand(command: string): DraftHandleValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (command === <span class="string">'my-key'</span>) &#123;</span><br><span class="line">      <span class="comment">// do something ...</span></span><br><span class="line">      <span class="comment">// 必须返回'handled', 告诉Draft.js采用修改,设置新的editorState</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">'handled'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'not-handled'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Editor</span><br><span class="line">        editorState=&#123;<span class="keyword">this</span>.state.editorState&#125;</span><br><span class="line">        handleKeyCommand=&#123;<span class="keyword">this</span>.handleKeyCommand&#125;</span><br><span class="line">        keyBindingFn=&#123;myKeyBindingFn&#125;</span><br><span class="line">        ...</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myKeyBindingFn</span>(<span class="params">e: SyntheticKeyboardEvent</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.keyCode === <span class="number">83</span> &amp;&amp; hasCommandModifier(e)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'my-key'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> getDefaultKeyBinding(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h3><p>在开发富文本编辑器中, 最常用的还是样式按钮. 看Draft.js如何监听一次点击事件设置样式.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// …</span></span><br><span class="line">  handleBoldClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.onChange(RichUtils.toggleInlineStyle(<span class="keyword">this</span>.state.editorState, <span class="string">'BOLD'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleBoldClick.bind(<span class="keyword">this</span>)&#125;&gt;Bold&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Editor</span></span><br><span class="line"><span class="regexp">          editorState=&#123;this.state.editorState&#125;</span></span><br><span class="line"><span class="regexp">          handleKeyCommand=&#123;this.handleKeyCommand&#125;</span></span><br><span class="line"><span class="regexp">          onChange=&#123;this.onChange&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>RichUtils.toggleInlineStyle(this.state.editorState, ‘BOLD’)将当前选择的文字设置为加粗样式, 返回修改后的editorState, ‘BOLD’是Draft.js设置好的样式名称, 其他的还有’ITALIC’, ‘UNDERLINE’, 和 ‘CODE’. 这些样式名称可以直接使用. 要想获得丰富的富文本样式, 肯定要自己定义一套样式规则.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Editor&#125; <span class="keyword">from</span> <span class="string">'draft-js'</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * styleMap用来定义渲染规则 </span></span><br><span class="line"><span class="comment"> * key值是样式的名称, 在RichUtils.toggleInlineStyle(EditorState, key)中使用</span></span><br><span class="line"><span class="comment"> * value是渲染的css规则, 其中用驼峰格式来标识样式属性</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">const</span> styleMap = &#123;</span><br><span class="line">  <span class="string">'STRIKETHROUGH'</span>: &#123;</span><br><span class="line">    textDecoration: <span class="string">'line-through'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'COLOR_RED'</span>: &#123;</span><br><span class="line">    color: <span class="string">'red'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  handleLineThrough() &#123;</span><br><span class="line">    <span class="keyword">this</span>.onChange(RichUtils.toggleInlineStyle(<span class="keyword">this</span>.state.editorState, <span class="string">'COLOR_RED'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleLineThrough.bind(<span class="keyword">this</span>)&#125;&gt;删除线&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Editor</span></span><br><span class="line"><span class="regexp">          customStyleMap=&#123;styleMap&#125; /</span><span class="regexp">/ 必须在这里指定自定义的样式规则</span></span><br><span class="line"><span class="regexp">          editorState=&#123;this.state.editorState&#125;</span></span><br><span class="line"><span class="regexp">          ...</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>现在, 行内样式已经搞定了. 在实际开发中, 最好将行内样式定义放在一个单独的文件中, 在要使用的地方用import导入进来, 更近一步可以将执行修改的逻辑也放在控制层, 组件只负责渲染.  </p><h2 id="块级样式"><a href="#块级样式" class="headerlink" title="块级样式"></a>块级样式</h2><p>Draft.js提供了常用的块级样式类型:  </p><table><thead><tr><th style="text-align:left">HTML element</th><th style="text-align:left">Draft block type</th></tr></thead><tbody><tr><td style="text-align:left">&lt;h1/></td><td style="text-align:left">header-one</td></tr><tr><td style="text-align:left">&lt;h2/></td><td style="text-align:left">header-two</td></tr><tr><td style="text-align:left">&lt;h3/></td><td style="text-align:left">header-three</td></tr><tr><td style="text-align:left">&lt;h4/></td><td style="text-align:left">header-four</td></tr><tr><td style="text-align:left">&lt;h5/></td><td style="text-align:left">header-five</td></tr><tr><td style="text-align:left">&lt;h6/></td><td style="text-align:left">header-six</td></tr><tr><td style="text-align:left">&lt;blockquote/></td><td style="text-align:left">blockquote</td></tr><tr><td style="text-align:left">&lt;pre/></td><td style="text-align:left">code-block</td></tr><tr><td style="text-align:left">&lt;figure/></td><td style="text-align:left">atomic</td></tr><tr><td style="text-align:left">&lt;li/></td><td style="text-align:left">unordered-list-item,ordered-list-item**</td></tr><tr><td style="text-align:left">&lt;div/></td><td style="text-align:left">unstyled***</td></tr></tbody></table><p>blockStyleFn属性可以让开发者自己定义渲染块级样式的class, 贴上官网的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Editor&#125; <span class="keyword">from</span> <span class="string">'draft-js'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myBlockStyleFn</span>(<span class="params">contentBlock</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> type = contentBlock.getType();</span><br><span class="line">  <span class="keyword">if</span> (type === <span class="string">'blockquote'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'superFancyBlockquote'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EditorWithFancyBlockquotes</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;Editor ... blockStyleFn=&#123;myBlockStyleFn&#125; /&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在css文件中定义superFancyBlockquote类的样式:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.superFancyBlockquote</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'Hoefler Text'</span>, Georgia, serif;</span><br><span class="line">  <span class="attribute">font-style</span>: italic;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>blockRenderMap属性可以让开发者自己定义块的渲染规则, 可以覆盖默认规则, 也可以添加新的规则.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> blockRenderMap = Immutable.Map(&#123;</span><br><span class="line">  <span class="string">'header-two'</span>: &#123;</span><br><span class="line">    element: <span class="string">'div'</span> <span class="comment">// 覆盖了默认的规则</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 定义新类型</span></span><br><span class="line">  <span class="string">'ul-disc'</span>: &#123; </span><br><span class="line">    element: <span class="string">'li'</span>, <span class="comment">// 渲染标签</span></span><br><span class="line">    wrapper: React.createElement(<span class="string">'ul'</span>, &#123; <span class="attr">className</span>: <span class="string">'public-DraftStyleDefault-ul ul-disc'</span> &#125;) <span class="comment">// 定义包裹的组件, 类名加上默认的类名和自定义的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 需要merge到默认的规则里边</span></span><br><span class="line"><span class="keyword">const</span> extendedBlockRenderMap = DefaultDraftBlockRenderMap.merge(getBlockRender())</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RichEditor</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  handleUlClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.onChange(</span><br><span class="line">      RichUtils.toggleBlockType(</span><br><span class="line">        <span class="keyword">this</span>.state.editorState,</span><br><span class="line">        <span class="string">'ul-disc'</span></span><br><span class="line">    ));</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.handleUlClick.bind(<span class="keyword">this</span>)&#125;&gt;UL&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Editor</span></span><br><span class="line"><span class="regexp">          ...</span></span><br><span class="line"><span class="regexp">          blockRenderMap=&#123;extendedBlockRenderMap&#125;</span></span><br><span class="line"><span class="regexp">        /</span>&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>需要在自己的样式表中定义.ul-disc的样式, 样式表必须引入才能生效:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ul-disc</span>&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>: disc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>先附上自己写的初版富文本链接<a href="https://zhangxuekang.com/rich-text/index.html">demo</a>.<br><img src="https://zhangxuekang.com/src/blog/draft-rich-text/text-editor.png" alt="富文本编辑器"><br>这就是Draft.js的基础应该用, 更多的功能例如超链接, 图片等有时间再撰文介绍. 打铁还需自身硬, 要想使用好Draft.js, 要需要自己去多研究多实践. 官网介绍挺全的(就是一些API很不友好). 附上官网的链接<a href="https://draftjs.org/" target="_blank" rel="noopener">https://draftjs.org/</a>. 知乎也是用的Draft.js构建的富文本编辑器, 但是知乎也只用了Draft.js的皮毛, 足以支撑起一个普通的文章编辑和评论编辑器了. 如果你想要构建一个online word, 只能祝你好运.<br>附上两篇相关文章:<br><em><a href="https://zhuanlan.zhihu.com/p/24951621" target="_blank" rel="noopener">Draft.js 在知乎的实践</a></em><br><em><a href="https://www.zhihu.com/question/38699645" target="_blank" rel="noopener">为什么都说富文本编辑器是天坑?</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://draftjs.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Draft.js&lt;/a&gt;是一个构建富文本编辑器的React框架, 它不是一个富文本编辑器的组件库. draft.js提供构建编辑器的工具, 如何实现,
      
    
    </summary>
    
      <category term="react" scheme="https://zhangxuekang.com/categories/react/"/>
    
    
      <category term="富文本" scheme="https://zhangxuekang.com/tags/%E5%AF%8C%E6%96%87%E6%9C%AC/"/>
    
      <category term="draft.js" scheme="https://zhangxuekang.com/tags/draft-js/"/>
    
      <category term="react" scheme="https://zhangxuekang.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>记录鼠标轨迹, 生成svg路径</title>
    <link href="https://zhangxuekang.com/2019/03/30/mouse-svg/"/>
    <id>https://zhangxuekang.com/2019/03/30/mouse-svg/</id>
    <published>2019-03-30T00:50:45.000Z</published>
    <updated>2019-04-07T00:36:53.023Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;业务上遇到了这样的问题, 在浏览器中, 使元素沿着用户画出的路径移动. 因为让元素沿着svg路径移动已经实现了, 所以需要做的是用鼠标画出路径. 鼠标方法只能获取鼠标在页面中的实时坐标, 是离散的坐标点, 如何将这些坐标点转化成平滑的路径是问题的关键.<br><img src="https://zhangxuekang.com/src/blog/mouse-svg/svg.png" alt="三次贝塞尔曲线"><br>&emsp;&emsp;svg的三次贝塞尔曲线需要定义一个点和两个控制点, 所以用C命令创建三次贝塞尔曲线, 需要设置三组坐标参数(c dx1 dy1, dx2 dy2, dx dy). <em><a href="https://developer.mozilla.org/zh-CN/docs/Web/SVG/Tutorial/Paths#Curve_commands" target="_blank" rel="noopener">这里的最后一个坐标(dx, dy)表示的是曲线的终点, 另外两个坐标是控制点, (dx1, dy1)是起点的控制点, (dx2, dy2)是终点的控制点</a></em>. 终点的坐标点好说, 也就是获取的鼠标位置点, 难的是如何得到两个控制点.<br>&emsp;&emsp;网上搜索解决办法, 在百度文库上发现了一篇文章介绍控制点的确定方法(<em><a href="https://wenku.baidu.com/view/c790f8d46bec0975f565e211.html" target="_blank" rel="noopener">贝塞尔曲线控制点确定的方法</a></em>). 现在来尝试下用这个方法转化坐标.<br>&emsp;&emsp;假设获取的一系列鼠标坐标保存在数组data[]中.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = [x1, y1, x2, y2, x3, y3, x4, y4, x5, y5, x6, y6, x7, y7, ...];</span><br></pre></td></tr></table></figure></p><p>以(x3, y3)点为例.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * a为系数，可以尝试不同系数，观察结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 后控制点计算</span></span><br><span class="line"><span class="keyword">const</span> dx1 = x3 + a(x4 - x2);</span><br><span class="line"><span class="keyword">const</span> dy1 = y3 + a(y4 - y2);</span><br><span class="line"><span class="comment">// 前控制点计算</span></span><br><span class="line"><span class="keyword">const</span> dx2 = x4 - a(x5 - x3);</span><br><span class="line"><span class="keyword">const</span> dy2 = y4 - a(y5 - y3);</span><br></pre></td></tr></table></figure></p><p>那么依次求出每对点的控制点，就能连成一条平滑的曲线了. 开始的一对点作为起点不用求，第二对和最后一对点作为计算点，不做为记录点.<br>贴上完整代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">solve</span>(<span class="params">data, k = <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> size = data.length</span><br><span class="line">  <span class="keyword">const</span> last = size - <span class="number">4</span></span><br><span class="line">  <span class="keyword">let</span> path = <span class="string">`M<span class="subst">$&#123;data[<span class="number">0</span>]&#125;</span>,<span class="subst">$&#123;data[<span class="number">1</span>]&#125;</span>`</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; size - <span class="number">2</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> x0 = i ? data[i - <span class="number">2</span>] : data[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> y0 = i ? data[i - <span class="number">1</span>] : data[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> x1 = data[i + <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">const</span> y1 = data[i + <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// x2 和 y2 作为终点坐标</span></span><br><span class="line">    <span class="keyword">const</span> x2 = data[i + <span class="number">2</span>]</span><br><span class="line">    <span class="keyword">const</span> y2 = data[i + <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">const</span> x3 = i !== last ? data[i + <span class="number">4</span>] : x2</span><br><span class="line">    <span class="keyword">const</span> y3 = i !== last ? data[i + <span class="number">5</span>] : y2</span><br><span class="line">    <span class="comment">// 计算控制点</span></span><br><span class="line">    <span class="keyword">const</span> cp1x = x1 + (x2 - x0) / <span class="number">6</span> * k</span><br><span class="line">    <span class="keyword">const</span> cp1y = y1 + (y2 - y0) / <span class="number">6</span> * k</span><br><span class="line">    <span class="keyword">const</span> cp2x = x2 - (x3 - x1) / <span class="number">6</span> * k</span><br><span class="line">    <span class="keyword">const</span> cp2y = y2 - (y3 - y1) / <span class="number">6</span> * k</span><br><span class="line">    path += <span class="string">` C<span class="subst">$&#123;cp1x&#125;</span>,<span class="subst">$&#123;cp1y&#125;</span>,<span class="subst">$&#123;cp2x&#125;</span>,<span class="subst">$&#123;cp2y&#125;</span>,<span class="subst">$&#123;x2&#125;</span>,<span class="subst">$&#123;y2&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> path</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em><a href="https://zhangxuekang.com/mouse-svg/index.html">查看在线demo</a></em></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;业务上遇到了这样的问题, 在浏览器中, 使元素沿着用户画出的路径移动. 因为让元素沿着svg路径移动已经实现了, 所以需要做的是用鼠标画出路径. 鼠标方法只能获取鼠标在页面中的实时坐标, 是离散的坐标点, 如何将这些坐标点转化成平滑的路径是问题的关键
      
    
    </summary>
    
      <category term="javascript" scheme="https://zhangxuekang.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://zhangxuekang.com/tags/javascript/"/>
    
      <category term="鼠标" scheme="https://zhangxuekang.com/tags/%E9%BC%A0%E6%A0%87/"/>
    
      <category term="svg" scheme="https://zhangxuekang.com/tags/svg/"/>
    
  </entry>
  
  <entry>
    <title>js简单实现的鼠标跟随效果</title>
    <link href="https://zhangxuekang.com/2019/03/22/mouse-string/"/>
    <id>https://zhangxuekang.com/2019/03/22/mouse-string/</id>
    <published>2019-03-22T06:52:43.000Z</published>
    <updated>2019-04-07T00:36:53.023Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;记得早年风靡装饰非主流QQ空间, 各种克隆空间的网站大行其道. 如果复制了某个狂拽酷炫的空间(必须有DJ背景音乐, 必须有轮播的视频图片, 配色必须黑底花字, 最好有鼠标跟随特效…)那么感觉自己就像是这条街最帅的仔了. 现在回忆起往事, 感慨万千, 时光一去不复返, 如果能穿越回去, 我一定扇死自己:)<br>&emsp;&emsp;虽然回忆起来就辣眼睛, 但是鼠标跟随特效还是很有应用前途的(强迫让自己相信). 曾经见过一个我认为最牛逼的纯css实现方案, 将页面铺满小div元素, 根据窗口绝对定位, 每个div都有:hover反应, 只要你的div足够小足够多, 看起来就像是鼠标跟随特效的, 如果再加上点延迟效果, 前途不可限量.<br>&emsp;&emsp;既然css方案这么牛逼, 所以我选择用js实现(逃). 思路就是给window加鼠标移动监听事件, 获取鼠标的位置信息, 将位置信息赋给一个绝对定位的元素.<br>&emsp;&emsp;来看下代码, 先creat个相对于body绝对定位的元素:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> $follow = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">$follow.setAttribute(<span class="string">'class'</span>, <span class="string">'follow'</span>);</span><br><span class="line">$body.appendChild($follow);</span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.follow</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;元素已经有了, 现在添加事件:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="built_in">parseFloat</span>(e.clientX);</span><br><span class="line">  <span class="keyword">const</span> y = <span class="built_in">parseFloat</span>(e.clientY);</span><br><span class="line">  $follow.style.left = x + <span class="string">'px'</span>;</span><br><span class="line">  $follow.style.top = y + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;移动跟随效果有了, 但是要多丑有多丑. 还有个小问题, 刚进入页面鼠标还没有移动的时候, 方块显示在左上角位置. 在css中加条规则:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.follow</span>&#123;</span><br><span class="line">  // ...</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">none</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后在事件中设置显示. 为了看起来更和谐, 将元素定位在鼠标的右边20px和下边20px处.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'mousemove'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  $follow.style.display = <span class="string">'block'</span>;</span><br><span class="line">  $follow.style.left = x + <span class="number">20</span> + <span class="string">'px'</span>;</span><br><span class="line">  $follow.style.top = y + <span class="number">20</span> + <span class="string">'px'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可以将丑爆的背景颜色替换成背景图片, 最好还是动态的gif图, 看起来更有逼格.<br>&emsp;&emsp;原理很简单, 也就是入门一周的水平, 但是设计好了会产生比较炫酷的效果.<br>&emsp;&emsp;28行js代码实现的一个小<a href="https://zhangxuekang.com/mouse-show/index.html">demo</a>.<br>&emsp;&emsp;<a href="https://github.com/zhangxuekang/mouse-show" target="_blank" rel="noopener">github地址</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;记得早年风靡装饰非主流QQ空间, 各种克隆空间的网站大行其道. 如果复制了某个狂拽酷炫的空间(必须有DJ背景音乐, 必须有轮播的视频图片, 配色必须黑底花字, 最好有鼠标跟随特效…)那么感觉自己就像是这条街最帅的仔了. 现在回忆起往事, 感慨万千, 
      
    
    </summary>
    
      <category term="javascript" scheme="https://zhangxuekang.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://zhangxuekang.com/tags/javascript/"/>
    
      <category term="鼠标跟随" scheme="https://zhangxuekang.com/tags/%E9%BC%A0%E6%A0%87%E8%B7%9F%E9%9A%8F/"/>
    
  </entry>
  
  <entry>
    <title>当你在javascript中用&quot;==&quot;的时候, 你在比较什么?</title>
    <link href="https://zhangxuekang.com/2019/03/19/coercion/"/>
    <id>https://zhangxuekang.com/2019/03/19/coercion/</id>
    <published>2019-03-19T05:46:25.000Z</published>
    <updated>2019-04-07T00:36:53.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>&nbsp;&nbsp;js中存在强制类型转换和隐式类型转换, 有意识地去调用转换方法或者构造函数去转换称为强制类型转换(implicit coercion), 无意识地转换(语言机制自发完成)称为隐式类型转换(explicit coercion).<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">42</span></span><br><span class="line"><span class="keyword">const</span> b = a + <span class="string">""</span> <span class="comment">// implicit coercion</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="built_in">String</span>( a ) <span class="comment">// explicit coercion</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">这里稍后会讨论的"=="问题, 涉及到的也是隐式类型转换.  </span></span><br><span class="line"><span class="string">转换的目标只能是string, number or boolean. 不可能经过隐式类型转换, 转换出一个复杂类型的数据(Object, Array, Function ...). 现在来看看各个类型的ToString,ToNumber, ToBoolean, 或者说是ToPrimitive.  </span></span><br><span class="line"><span class="string">### ToString  </span></span><br><span class="line"><span class="string">* 原生简单对象转化规则  </span></span><br><span class="line"><span class="string">  **null**: 转化为字符串"null";  </span></span><br><span class="line"><span class="string">  **undefined**: 转化为"undefined";  </span></span><br><span class="line"><span class="string">  **true/false**: 转化为"true"/"false";  </span></span><br><span class="line"><span class="string">  **Number**: 大部分情况如预测地那样, 2转化为"2", 0转化为"0", 100转化为"100". 但是事情没有这么简单. 不是10进制的数字, 首先会转化为十进制, 然后再转化为字符串, 并不是数字直接加上引号就行了.  </span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  (<span class="number">0x23</span>).toString() <span class="comment">// "35"</span></span><br><span class="line">  <span class="number">0x23</span> == <span class="string">"35"</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>  绝对值很大的数值或者绝对值很小的数值, 首先会转化为科学计数法, 然后再进行转化.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  (<span class="number">0.0000001</span>).toString() <span class="comment">// "1e-7"</span></span><br><span class="line">  (<span class="number">1000000000000000000000</span>).toString() <span class="comment">// "1e+21"</span></span><br><span class="line">  <span class="number">0.0000001</span> == <span class="string">"1e-7"</span> <span class="comment">// true</span></span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">* 复杂对象的转化规则  </span></span><br><span class="line"><span class="string">  **Object**: 如果没有指定自己的toString()方法, 就会调用Object.prototype.toString(). 这个函数会返回对象类型字符串, 在这里是"[object Object]". 如果指定了自己的toString()函数, 会执行这个函数, 使用返回值.</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> obj42 = &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="string">"ultimate"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  obj == <span class="string">"[object Object]"</span> <span class="comment">// true</span></span><br><span class="line">  obj42 == <span class="string">"ultimate"</span> <span class="comment">// true</span></span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">  **Array**: Array类型"重载"了Object.prototype.toString(), toString方法返回有一个以","隔开的数组元素拼接的字符串.</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>]</span><br><span class="line">  <span class="built_in">console</span>.log(arr) <span class="comment">// "a,b,c,d,e,f"</span></span><br><span class="line">  <span class="comment">// 修改数组的默认toString方法 别这样做</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.toString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.split(<span class="string">'-'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>] == <span class="string">"a-b-c-d-e-f"</span> <span class="comment">// true</span></span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">  **Function**: Function类型也重载了Object.prototype.toString(), 个性化的toString返回函数的字符串形式.  </span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> s = <span class="number">2</span>;<span class="keyword">return</span> s&#125;) == <span class="string">"function()&#123;var s = 2;return s&#125;"</span></span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">### ToNumber  </span></span><br><span class="line"><span class="string">* 基本类型转化规则  </span></span><br><span class="line"><span class="string">  **null**: 转化为0!;  </span></span><br><span class="line"><span class="string">  **undefined**: 转化为NaN;  </span></span><br><span class="line"><span class="string">  **true/false**: 转化为1/0;  </span></span><br><span class="line"><span class="string">  **String**: 字符串会尝试使用Number()构造函数(误)去转化结果, 转化失败不会报错, 会返回特殊的数字类型值NaN. 在这种操作中可以正确辨识以0x(0X)为起始符号的16进制的数字字符串, 但是会忽略以"0"起始的部分.  </span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  <span class="number">10</span> - <span class="literal">null</span> <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">isNaN</span>(<span class="literal">undefined</span>) <span class="comment">// true</span></span><br><span class="line">  <span class="number">1</span> + <span class="literal">true</span> <span class="comment">// 2</span></span><br><span class="line">  <span class="number">2</span> - <span class="literal">false</span> <span class="comment">// 2</span></span><br><span class="line">  <span class="number">20</span> - <span class="string">"0xb"</span> <span class="comment">// 9</span></span><br><span class="line">  <span class="number">20</span> - <span class="string">"013"</span> <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></p><p>  还有一种特殊情况是, 如果是合法的科学计数法数字字符串, 能正常转化为10进制的数字<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="string">"1e+10"</span> == <span class="number">10000000000</span> <span class="comment">// true</span></span><br><span class="line">  <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">* 复杂对象的转化规则  </span></span><br><span class="line"><span class="string">  首先复杂对象会调用内部的ToPrimitive方法, 尝试转化成基础类型值, 如果基础类型值不是number, 则再进行转化. 调用ToPrimitive可以想成首先尝试调用对象的valueOf()方法, 如果有这个方法并且返回的是基础类型值则使用返回值, 否则就尝试调用toString()方法. 如果这两个方法都不存在或者返回值都不是基础类型值, 会抛出TypeError错误.</span></span><br><span class="line"><span class="string">  `</span><span class="string">``</span>js</span><br><span class="line">  <span class="keyword">const</span> a = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="string">"1"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">10</span> - a <span class="comment">// 9</span></span><br><span class="line">  <span class="keyword">const</span> b = &#123;</span><br><span class="line">    toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="string">"2"</span>&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">10</span> - b <span class="comment">// 8</span></span><br><span class="line">  <span class="keyword">const</span> c = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="string">"3"</span>&#125;, <span class="comment">// 首先调用</span></span><br><span class="line">    toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="string">"4"</span>&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">10</span> - c <span class="comment">// 7</span></span><br><span class="line">  <span class="keyword">const</span> d = &#123;</span><br><span class="line">    valueOf: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> &#123;&#125;&#125;, <span class="comment">// 首先调用</span></span><br><span class="line">    toString: <span class="function"><span class="params">()</span> =&gt;</span> &#123;<span class="keyword">return</span> <span class="string">"5"</span>&#125;, <span class="comment">// 调用valueOf结果不对, 调用toString</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">10</span> - d <span class="comment">// 5</span></span><br><span class="line">  <span class="keyword">const</span> e = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="number">10</span> - e <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></p><h3 id="ToBoolean"><a href="#ToBoolean" class="headerlink" title="ToBoolean"></a>ToBoolean</h3><p>  先来看一定是false的几个值  </p><ul><li>undefined  </li><li>null  </li><li>false  </li><li>+0, -0, and NaN  </li><li><p>“”  </p><p>这个列表外的值, 都是true(误, 有例外). 复杂类型的值都是true(误, 有例外)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="literal">false</span> ) <span class="comment">// true</span></span><br><span class="line">!!<span class="keyword">new</span> <span class="built_in">Boolean</span>( <span class="number">0</span> ) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在史前时代, 人们判断是不是IE浏览器, 往往用这样的代码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.all) &#123; <span class="comment">/* it's IE */</span> &#125;</span><br></pre></td></tr></table></figure><p>结果慢慢地, 别的浏览器也开始有这个API了. 可是旧代码已经沉淀下来成了地层中的岩石, 挖出来修改的成本太高了, 干脆在非IE浏览器中document.all是falsy算了, 所以导致了这个对象的奇葩行为.  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!!<span class="built_in">document</span>.all <span class="comment">// true 在IE11以下版本</span></span><br><span class="line">!!<span class="built_in">document</span>.all <span class="comment">// false 在IE11以上版本或非IE环境</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="“-”-VS-“-”"><a href="#“-”-VS-“-”" class="headerlink" title="“==” VS. “===”"></a>“==” VS. “===”</h2><p>  两者的区别是: “==”比较的时候, 允许隐式类型转换, “===”不允许隐式类型转换.<br>  稍微提下”===”的两个奇葩行为:</p><ul><li>NaN === NaN // false</li><li>-0 === +0 // true </li></ul><h2 id="“-”规则"><a href="#“-”规则" class="headerlink" title="“==”规则"></a>“==”规则</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">42</span> === <span class="string">'42'</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == <span class="string">'42'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>  问题来了, 42 == ‘42’到底隐式转换成了什么? 是42 == 42还是’42’==’42’? 接下来就详细介绍下转换的规则, 了解这些规则后, “==”很多诡异的行为都变得有理有据, 再也不用视为”糟粕”不敢用了.  </p><h3 id="String-VS-Number"><a href="#String-VS-Number" class="headerlink" title="String VS. Number"></a>String VS. Number</h3><blockquote><p>If Type(x) is Number and Type(y) is String, return the result of the comparison x == ToNumber(y).<br>  If Type(x) is String and Type(y) is Number, return the result of the comparison ToNumber(x) == y.  </p></blockquote><p>  如果”==”两边是字符串和数字, 那么字符串转化为数字去比较.<br>  字符串转化为数字的规则, 上边有介绍.  </p><h3 id="Anything-VS-Boolean"><a href="#Anything-VS-Boolean" class="headerlink" title="Anything VS. Boolean"></a>Anything VS. Boolean</h3><blockquote><p>If Type(x) is Boolean, return the result of the comparison ToNumber(x) == y.<br>  If Type(y) is Boolean, return the result of the comparison x == ToNumber(y).  </p></blockquote><p>  如果”==”两边是Boolean值和其他值, 那么第一步会将Boolean值转化为数字, 转化的结果只能是0或1. 然后再用0或1去和其他值比较, 如果其他值是复杂类型的值, 再进行其他转换, 如果是字符串, 参考上一条.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span> == <span class="string">'1'</span> <span class="comment">// 1 == '1' -&gt; 1 == 1 true</span></span><br><span class="line"><span class="literal">true</span> == <span class="string">'42'</span>  <span class="comment">// 1 == '42' -&gt; 1 == 42 false</span></span><br><span class="line"><span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">###  null VS. undefined  </span></span><br><span class="line"><span class="string">&gt; If x is null and y is undefined, return true.  </span></span><br><span class="line"><span class="string">If x is undefined and y is null, return true.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果是null和undefined作比较, 返回true. 这俩哥们和其他的任何值作比较, 都返回false.</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="literal">undefined</span></span><br><span class="line">a == b <span class="comment">// true</span></span><br><span class="line">a == <span class="literal">null</span><span class="comment">// true</span></span><br><span class="line">b == <span class="literal">null</span><span class="comment">// true</span></span><br><span class="line">a == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line">b == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line">a == <span class="string">""</span><span class="comment">// false</span></span><br><span class="line">b == <span class="string">""</span><span class="comment">// false</span></span><br><span class="line">a == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line">b == <span class="number">0</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h3 id="Objects-VS-non-Objects"><a href="#Objects-VS-non-Objects" class="headerlink" title="Objects VS. non-Objects"></a>Objects VS. non-Objects</h3><blockquote><p>If Type(x) is either String or Number and Type(y) is Object, return the result of the comparison x == ToPrimitive(y).<br>  If Type(x) is Object and Type(y) is either String or Number, return the result of the comparison ToPrimitive(x) == y.</p></blockquote><p>  当复杂类型与基本类型作比较的时候, 复杂类型值首先要转换成基本类型的值, 转化规则前边有介绍.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'42'</span>] == <span class="number">42</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>(<span class="number">10</span>) == <span class="string">'10'</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p><p>  两点需要注意, 构造函数的参数是null或者undefined, 会返回一个”空”对象, 所以下边的结果是有道理的.<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">Object</span>( <span class="literal">null</span> ) <span class="comment">// &#123;&#125;</span></span><br><span class="line">a == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">Object</span>( <span class="literal">undefined</span> ) <span class="comment">// &#123;&#125;</span></span><br><span class="line">b == <span class="literal">undefined</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><h2 id="最后练习"><a href="#最后练习" class="headerlink" title="最后练习"></a>最后练习</h2>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// true [] == false -&gt; [] == 0 -&gt; "" == 0 -&gt; 0 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> == [<span class="number">2</span>] <span class="comment">// true  2 == "2" -&gt; 2 == 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span> == [<span class="literal">null</span>] <span class="comment">// true  "" == ""  (ps: String([null]) === "";  String(null) === "null")</span></span><br><span class="line"></span><br><span class="line"><span class="string">"0"</span> == <span class="literal">false</span> <span class="comment">// true "0" == 0 -&gt; 0 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span> <span class="comment">// true 0 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == <span class="string">""</span> <span class="comment">// true 0 == "" -&gt; 0 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="literal">false</span> == [] <span class="comment">// true 0 == [] -&gt; 0 == "" -&gt; 0 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span> == <span class="number">0</span> <span class="comment">// true 0 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="string">""</span> == [] <span class="comment">// true "" == ""</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> == [] <span class="comment">// true 0 == "" -&gt; 0 == 0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;类型转换&quot;&gt;&lt;a href=&quot;#类型转换&quot; class=&quot;headerlink&quot; title=&quot;类型转换&quot;&gt;&lt;/a&gt;类型转换&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;js中存在强制类型转换和隐式类型转换, 有意识地去调用转换方法或者构造函数去转换称为强制类型转换(i
      
    
    </summary>
    
      <category term="javascript" scheme="https://zhangxuekang.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="https://zhangxuekang.com/tags/javascript/"/>
    
      <category term="==" scheme="https://zhangxuekang.com/tags//"/>
    
      <category term="类型转换" scheme="https://zhangxuekang.com/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
</feed>
